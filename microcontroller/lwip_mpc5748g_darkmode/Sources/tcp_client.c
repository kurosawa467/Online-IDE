#include "lwip/netif.h" /* struct netif, netif_add, netif_set_up, netif_set_default */
#include "lwip/dhcp.h" /* struct dhcp, dhcp_set_struct, dhcp_start */
#include "lwip/tcp.h" /* struct tcp_pcb, tcp_new, tcp_bind, tcp_write, tcp_output, tcp_close, tcp_connect, TCP_WRITE_FLAG_COPY */
#include "lwip/sys.h" /* sys_init; S32DS (linker) will provide port-specific impl. (e.g., `SDK/middleware/tcpip/tcpip_stack/ports/OS/sys_arch.c`) */
#include "lwip/init.h" /* lwip_init */
#include "lwip/timeouts.h" /* sys_check_timeouts */
#include "lwip/ip_addr.h" /* ip_addr_t, ipaddr_aton, ip_addr_set_zero  */

/* device specific driver code */
/* generated by S32DS in `SDK/middleware/tcpip/tcpip_stack/ports/netif/enetif.h` */
#include "enetif.h" /* enet_ethernetif_init, enet_poll_interface, enet_ethernetif_shutdown */

/* globales variables for netifs */
/* THE ethernet interface */
struct netif netif;

/* DHCP struct for the ethernet netif */
extern struct dhcp netif_dhcp;

/* TCP/IP protocol control block */
static struct tcp_pcb *pcb;

/**
 * Set up network interface and start DHCP negotiation for it.
 */
static void enetif_init(void) {
	ip_addr_t ipaddr, netmask, gw;
	err_t err;

	/* fill all IP address structures with zeroes */
#define NETIF_ADDRS &ipaddr, &netmask, &gw,
	ip_addr_set_zero(&gw);
	ip_addr_set_zero(&ipaddr);
	ip_addr_set_zero(&netmask);

	/* add a network interface to the list of lwIP netifs */
	netif_add(&netif, NETIF_ADDRS NULL, enet_ethernetif_init, netif_input);

	/* set a network interface as the default network interface */
	netif_set_default(&netif);

	/* set a statically allocated struct dhcp to work with */
	dhcp_set_struct(&netif, &netif_dhcp);

	/* bring an interface up, available for processing traffic */
	netif_set_up(&netif);

	/* start DHCP negotiation for network interface */
	err = dhcp_start((struct netif *) &netif);
}

static err_t connection_callback(void *arg, struct tcp_pcb *tpcb, err_t err) {

	// TODO: implement
	//const *message = "HEAD /dark-mode/toggle HTTP/1.0\r\n\r\n";
	const *message = "GET /dark-mode/toggle HTTP/1.0\r\n\r\n";
	u16_t message_len = 40;

	err_t error = tcp_write(tpcb, message, message_len, TCP_WRITE_FLAG_COPY);

	//TODO: some error handling
	if (error){
		return 1;
	}

	error = tcp_output(tpcb);

	error = tcp_close(tpcb);

	return 0;
}

static void create_tcp_connection() {

	// TODO: implement
	ip_addr_t remote_ip;
	ip_addr_t local_ip;

	uint16_t remote_port = 8080;
	uint16_t local_port = 0; //will find any function available automatically

	ipaddr_aton("192.168.178.28", &remote_ip);
	ip_addr_set(&local_ip, &netif.ip_addr);

	pcb = tcp_new();
	tcp_bind(pcb, &local_ip, local_port);

	tcp_connect(pcb, &remote_ip, remote_port, connection_callback);
}

/**
 * Initialize networking and run main program loop.
 */
void start_tcp_client(bool *pointer_button) {
	/* init system architecture layer (initialization of timers) */
	sys_init();

	/* init lwIP single-threaded core: initialize the network stack */
	lwip_init();

	/* init network (ethernet) interface */
	enetif_init();

    /* a counter to control the frequency of requests sent */
	int counter = 0;

	int sent_three = 0;


	/* main loop for driver update and timers */
	while (1) {

		/* handle timers */
		sys_check_timeouts();

		/* poll ethernet packets and feed into network interface */
		(void) enet_poll_interface(&netif);

		/* if there is an IP address set for netif, we create a TCP connection */
		if (counter % 500000 == 0 && netif.ip_addr.addr) {

			//only if button is pressed
			if (*pointer_button){
				create_tcp_connection();
				*pointer_button = false;
			}
		}
		counter++;
	}

	/* release the network interface */
	enet_ethernetif_shutdown(&netif);
	}
